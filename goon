/******************************************************************************************
 *  GPT-4 ‚ÄúNANO‚Äù  ‚Äì  completely Gemini-free version
 *  - Every Gemini name changed to GPT
 *  - Every Gemini URL changed to GPT URL
 *  - Every function / variable / log string updated
 *  - Keeps identical logic & GUI
 ******************************************************************************************/
function createtermkClientGUI(mode) {
    /* ----------  GUI STYLES & MARK-UP  ---------- */
    const old = document.getElementById("uiverseGui");
    if (old) old.remove();

    const style = document.createElement("style");
    style.textContent = `
        #uiverseGui { position: fixed; padding: 1em; background: #f0f0f0; border-radius: .8em;
            box-shadow: 4px 4px 12px #c5c5c5, -4px -4px 12px #ffffff; z-index: 99999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 15px; user-select: none; font-family: Verdana,arial,helvetica,clean,sans-serif;
            color: #090909; }
        #uiverseGui .header { width: 100%; height: 5px; display: flex; justify-content: flex-end;
            align-items: center; cursor: move; margin-bottom: 0; }
        #uiverseGui .closeBtn { cursor: pointer; font-weight: bold; font-size: 14px;
            background: transparent; border: none; color: #090909; }
        #uiverseGui .title { font-size: 18px; font-weight: bold; text-align: center; margin-bottom: 10px; user-select: none; }
        #uiverseGui .device-label, #uiverseGui .auto-label { font-size: 16px; font-weight: bold;
            text-align: center; margin-bottom: 5px; user-select: none; }
        #uiverseGui button.uiverseBtn { color: #090909; padding: .4em 1em; font-size: 16px; font-weight: bold;
            border-radius: .5em; background: #e8e8e8; cursor: pointer; border: 1px solid #e8e8e8;
            transition: all .3s ease; box-shadow: 6px 6px 12px #c5c5c5, -6px -6px 12px #ffffff;
            display: block; user-select: none; margin-top: 2px; text-align: center; }
        #uiverseGui button.uiverseBtn:hover { border: 1px solid #fff; }
        #uiverseGui button.uiverseBtn:active { box-shadow: 4px 4px 12px #c5c5c5, -4px -4px 12px #ffffff; }
        .checkbox-apple { position: relative; width: 50px; height: 25px; margin: 0 auto; user-select: none; }
        .checkbox-apple input { opacity: 0; width: 0; height: 0; position: absolute; }
        .checkbox-apple label { position: absolute; top: 0; left: 0; width: 50px; height: 25px; border-radius: 50px;
            background: linear-gradient(to bottom, #b3b3b3, #e6e6e6); cursor: pointer; transition: all .3s ease; }
        .checkbox-apple label:after { content: ''; position: absolute; top: 1px; left: 1px; width: 23px; height: 23px;
            border-radius: 50%; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,.3); transition: all .3s ease; }
        .checkbox-apple input:checked + label { background: linear-gradient(to bottom, #4cd964, #5de24e); }
        .checkbox-apple input:checked + label:after { transform: translateX(25px); }
    `;
    document.head.appendChild(style);

    const gui = document.createElement("div");
    gui.id = "uiverseGui";

    const header = document.createElement("div");
    header.className = "header";
    const close = document.createElement("button");
    close.className = "closeBtn"; close.innerText = "√ó";
    close.onclick = () => {
        gui.remove();
        document.body.style.overflow = "";
        document.removeEventListener("touchmove", preventScroll, { passive: false });
    };
    header.appendChild(close);
    gui.appendChild(header);

    const title = document.createElement("div");
    title.className = "title"; title.innerText = "Term Client";
    gui.appendChild(title);

    if (mode === "autoMode") {
        const label = document.createElement("div");
        label.className = "auto-label"; label.innerText = "Auto Mode";
        gui.appendChild(label);

        const wrap = document.createElement("div");
        wrap.className = "checkbox-apple";
        const cb = document.createElement("input");
        cb.type = "checkbox"; cb.id = "appleCheckbox";
        const lbl = document.createElement("label");
        lbl.htmlFor = "appleCheckbox";
        wrap.append(cb, lbl);
        gui.appendChild(wrap);

        cb.addEventListener("change", () => {
            window.dispatchEvent(new KeyboardEvent("keydown", { key: "y", keyCode: 89, code: "KeyY", bubbles: true, cancelable: true }));
        });

        const btn = document.createElement("button");
        btn.className = "uiverseBtn"; btn.innerText = "Once";
        btn.onclick = () => {
            window.dispatchEvent(new KeyboardEvent("keydown", { key: "c", keyCode: 67, code: "KeyC", bubbles: true, cancelable: true }));
        };
        gui.appendChild(btn);
    } else {
        const dlabel = document.createElement("div");
        dlabel.className = "device-label"; dlabel.innerText = "Choose your device";
        gui.appendChild(dlabel);
        ["Mobile", "Computer"].forEach(t => {
            const b = document.createElement("button");
            b.className = "uiverseBtn"; b.innerText = t;
            b.onclick = () => createtermkClientGUI("autoMode");
            gui.appendChild(b);
        });
    }

    document.body.appendChild(gui);
    const rect = gui.getBoundingClientRect();
    gui.style.left = (window.innerWidth - rect.width) / 2 + "px";
    gui.style.top = (window.innerHeight - rect.height) / 2 + "px";

    /* ----------  DRAG SUPPORT  ---------- */
    let drag = false, offX = 0, offY = 0;
    function preventScroll(e) { if (drag) e.preventDefault(); }
    function start(x, y) {
        drag = true; document.body.style.overflow = "hidden";
        document.addEventListener("touchmove", preventScroll, { passive: false });
        const rr = gui.getBoundingClientRect();
        offX = x - rr.left; offY = y - rr.top;
    }
    function move(x, y) { if (!drag) return; gui.style.left = x - offX + "px"; gui.style.top = y - offY + "px"; }
    function stop() { drag = false; document.body.style.overflow = ""; document.removeEventListener("touchmove", preventScroll, { passive: false }); }

    gui.addEventListener("mousedown", e => { if (!e.target.closest("button,input,label")) start(e.clientX, e.clientY); });
    document.addEventListener("mousemove", e => move(e.clientX, e.clientY));
    document.addEventListener("mouseup", stop);
    gui.addEventListener("touchstart", e => { const t = e.touches[0]; if (!e.target.closest("button,input,label")) start(t.clientX, t.clientY); });
    document.addEventListener("touchmove", e => { if (drag) { const t = e.touches[0]; move(t.clientX, t.clientY); } });
    document.addEventListener("touchend", stop);
}

/* =========================================================================================
 *                              GPT-4 NANO  ‚Äì  CORE LOGIC
 * ========================================================================================= */
(function () {
    'use strict';
    console.clear();

    /* -------------------  CONFIG  ------------------- */
    const GITHUB_FILE_URL = "https://raw.githubusercontent.com/qpeyy/term/main/api";
    const GPT_MODEL       = "gpt-4o-mini";
    const GPT_BASE_URL    = "https://api.openai.com/v1/chat/completions";
    const GITHUB_PAT      = "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"
    /* ------------------------------------------------ */

    let API_KEY          = null;
    let autoModeActive   = false;
    let questionCounter  = 0;
    let apiChange        = 0;
    let apiKeysCache     = [];
    let isProcessing     = false;
    let lastKnownText    = "";
    let logTimeout       = null;
    let keyErrorCount    = {};
    let imageChoiceMap   = {};

    /* --------------  GPT API CONTEXT (iframe)  -------------- */
    async function initGPTAPI() {
        if (window.gptApi?.context) return window.gptApi.context;

        const frame = document.createElement("iframe");
        frame.src = "/dv3/" + Math.random().toString(36).slice(2);
        frame.style.display = "none";
        frame.id = "gptApiContext";
        document.body.appendChild(frame);

        await new Promise(resolve => {
            const t = setTimeout(resolve, 3000);
            frame.onload = () => { clearTimeout(t); resolve(); };
        });

        window.gptApi = {
            context: frame.contentWindow,
            fetch: frame.contentWindow?.fetch?.bind(frame.contentWindow) || window.fetch.bind(window)
        };
        log("‚úÖ gptApi context initialized");
        return window.gptApi.context;
    }

    /* --------------  FETCH HANDLER  -------------- */
    function getGPTFetch() {
        return window.gptApi?.fetch || window.fetch.bind(window);
    }

    /* --------------  LOGGER  -------------- */
    function log(msg) {
        console.log(`[GPT Helper] ${msg}`);
        const oldBox = document.getElementById("__gpt_log");
        if (oldBox) oldBox.remove();
        const box = document.createElement("div");
        box.id = "__gpt_log";
        Object.assign(box.style, {
            position: "fixed", bottom: "10px", right: "10px", background: "#fff", border: "1px solid #ccc",
            padding: "8px 12px", borderRadius: "8px", boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
            fontFamily: "monospace", fontSize: "12px", maxWidth: "600px", zIndex: 999999,
            whiteSpace: "pre-wrap", transition: "opacity 0.3s ease"
        });
        box.textContent = msg;
        document.body.appendChild(box);
        clearTimeout(logTimeout);
        logTimeout = setTimeout(() => { box.style.opacity = "0"; setTimeout(() => box.remove(), 300); }, 2000);
    }

    /* --------------  IMAGE HELPERS  -------------- */
    function labelImageChoices() {
        imageChoiceMap = {};
        let container = document.querySelector(".GriddyLayout.TOP") || document.querySelector(".VerticalLayout");
        if (!container) return [];
        const children = Array.from(container.children);
        const imageChoices = [];
        children.forEach((child, idx) => {
            const imgs = Array.from(child.querySelectorAll("img")).filter(img => {
                const src = img.src || img.getAttribute("src") || "";
                const cls = img.className || "";
                const isContent = cls.includes("image-base") || img.closest(".raster-image") || src.includes("/~media/");
                const isUI      = src.includes("check_mark") || src.includes("icon") || src.includes("/svg/") || src.endsWith(".svg") ||
                                  img.closest(".CheckMark") || img.closest(".practice-audio-button");
                return isContent && !isUI;
            });
            if (imgs.length) {
                const label = `IMAGE_CHOICE_${idx + 1}`;
                child.setAttribute("data-image-choice", label);
                imageChoiceMap[label] = child;
                imageChoices.push({ label, element: child, images: imgs });
                log(`üè∑Ô∏è Labeled choice as ${label} with ${imgs.length} image(s)`);
            }
        });
        return imageChoices;
    }
    async function imageToBase64(url) {
        try {
            const r = await fetch(url);
            const b = await r.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(",")[1]);
                reader.onerror   = reject;
                reader.readAsDataURL(b);
            });
        } catch (e) { log(`‚ùå Failed to convert image: ${e.message}`); return null; }
    }
    async function getImagesFromQuestion() {
        const el = document.querySelector(".question-component");
        if (!el) return { questionImages: [], choiceImages: [] };
        const imageChoices = labelImageChoices();
        const imgEls = Array.from(el.querySelectorAll("img")).filter(img => {
            const src = img.src || img.getAttribute("src") || "";
            const cls = img.className || "";
            const isContent = cls.includes("image-base") || img.closest(".raster-image") || src.includes("/~media/");
            const isUI      = src.includes("check_mark") || src.includes("icon") || src.includes("/svg/") || src.endsWith(".svg") ||
                              img.closest(".CheckMark") || img.closest(".practice-audio-button");
            return isContent && !isUI;
        });
        const questionImages = [];
        const choiceImages   = [];
        for (const img of imgEls) {
            try {
                let isChoice = false;
                for (const ch of imageChoices) if (ch.images.includes(img)) { isChoice = true; break; }
                const src = img.src || img.getAttribute("src");
                if (!src) continue;
                log(`üñºÔ∏è Found image: ${src.substring(0, 50)}...`);
                const b64 = await imageToBase64(src);
                if (b64) {
                    const mime = getMimeType(src);
                    const data = { type: "image_url", image_url: { url: `data:${mime};base64,${b64}` } };
                    (isChoice ? choiceImages : questionImages).push(data);
                    log(`‚úÖ Image converted to base64 data URL`);
                }
            } catch (err) { log(`‚ùå Error processing image: ${err.message}`); }
        }
        return { questionImages, choiceImages, imageChoices };
    }
    function getMimeType(u) {
        const ext = u.split(".").pop().split("?")[0].toLowerCase();
        return { jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", gif: "image/gif", webp: "image/webp", bmp: "image/bmp" }[ext] || "image/jpeg";
    }

    /* --------------  QUESTION TEXT  -------------- */
    function getQuestionText() {
        const el = document.querySelector(".question-component");
        if (!el) { log("üî¥ Question element not found."); return null; }
        let out = "";
        function walk(n) {
            if (n.nodeType === Node.TEXT_NODE) {
                const t = n.textContent.trim();
                if (t && t !== "=" && t.toLowerCase() !== "submit" && !/^\s*(Created with Snap|#|\.|;)/i.test(t)) out += t + " ";
            } else if (n.nodeType === Node.ELEMENT_NODE) {
                const cls = n.classList?.value || "";
                const tag = n.tagName?.toLowerCase();
                if (cls.includes("practice-audio-button has-inner-translation-button")) return;
                if (cls.includes("practice-audio-button-svg")) return;
                if (tag === "style" || tag === "script") return;
                if (cls.includes("old-superscript-in-expression")) {
                    const exp = n.innerText.trim();
                    out = out.trimEnd(); out += "^" + exp + " ";
                } else { n.childNodes.forEach(walk); }
            }
        }
        walk(el);
        return out.trim();
    }
    function getTargetElementText() {
        let t = document.getElementById("yui_3_18_1_1_1761275887189_552");
        if (!t) t = document.querySelector(".question-component");
        return t ? t.innerText.trim() : "";
    }
    async function waitForTextChange(prev, max = 30000) {
        log("‚è≥ Waiting for page content to change...");
        const start = Date.now();
        return new Promise(res => {
            const iv = setInterval(() => {
                const now = getTargetElementText();
                if (now !== prev && now.length > 0) { clearInterval(iv); log("‚úÖ Content changed! Proceeding..."); res(true); }
                else if (Date.now() - start > max) { clearInterval(iv); log("‚ö†Ô∏è Timeout waiting for content change."); res(false); }
            }, 100);
        });
    }

    /* --------------  API-KEY ROTATION  -------------- */
async function fetchKeyFromGitHub(force = false) {
    /* ---------- use cached keys if we already have them ---------- */
    if (apiKeysCache.length && !force) { /* continue below */ }
    else {
        /* ---------- create stealth iframe ---------- */
        const frame = document.createElement("iframe");
        frame.style.display = "none";
        frame.src = "/dv3/" + Math.random().toString(36).slice(2);
        document.body.appendChild(frame);

        /* ---------- wait for it to load ---------- */
        await new Promise(resolve => {
            const t = setTimeout(resolve, 3000);
            frame.onload = () => { clearTimeout(t); resolve(); };
        });

        /* ---------- grab its fetch ---------- */
        const ctx = frame.contentWindow;
        const f   = ctx?.fetch?.bind(ctx) || window.fetch.bind(window);

        log("üì¶ Fetching API keys from private GitHub repo (via iframe)‚Ä¶");
        try {
            const res = await f(GITHUB_FILE_URL + "?" + Date.now(), {
                method: "GET",
                headers: { Authorization: `token ${GITHUB_PAT}` } // ‚Üê PAT header
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const text = await res.text();
            apiKeysCache = text.split("\n").map(l => l.trim()).filter(l => l.length > 0);
            if (!apiKeysCache.length) throw new Error("No keys found");
        } catch (err) {
            log(`‚ùå Key fetch failed: ${err.message}`);
            return null;
        } finally {
            frame.remove(); // clean up iframe
        }
    }

    /* ---------- rotate key if needed ---------- */
    if (!API_KEY || apiChange >= 3) {
        API_KEY = apiKeysCache[Math.floor(Math.random() * apiKeysCache.length)];
        apiChange = 0;
        log("üîÅ Changed to a new API key.");
    }

    const vis = API_KEY.length > 10
        ? `${API_KEY.slice(0, 5)}...${API_KEY.slice(-5)}`
        : API_KEY;
    log(`üîë Using API key: ${vis}`);
    return API_KEY;
}

    /* --------------  CHOICE HELPERS  -------------- */
    function getAvailableChoices() {
        let c = document.querySelector(".GriddyLayout.TOP") || document.querySelector(".VerticalLayout");
        if (!c) return { choices: null, isMultipleSelect: false };
        const ch = Array.from(c.children);
        const choices = [];
        let isMS = false;
        ch.forEach(child => {
            const txt = child.innerText.trim();
            const lab = child.getAttribute("data-image-choice");
            if (lab) choices.push(lab);
            else if (txt && txt.length > 0 && txt !== "Submit") choices.push(txt);
            if (child.className && child.className.includes("MULTIPLE_SELECT")) isMS = true;
            if (child.querySelector && child.querySelector(".SelectableTile.MULTIPLE_SELECT")) isMS = true;
        });
        return { choices: choices.length ? choices : null, isMultipleSelect: isMS };
    }

    /* --------------  GPT CALL  -------------- */
    async function getAnswerFromGPT(question, apiKey) {
        await initGPTAPI();
        const { questionImages, choiceImages, imageChoices } = await getImagesFromQuestion();
        const { choices, isMultipleSelect } = getAvailableChoices();
        const hasImageChoices = imageChoices.length > 0 && choiceImages.length > 0;
        let prompt;
        if (choices && choices.length > 0) {
            if (hasImageChoices) {
                prompt = isMultipleSelect
                    ? `Look at the images provided in the question. Then look at the choice images. Each choice image is labeled (IMAGE_CHOICE_1, IMAGE_CHOICE_2, etc.). Choose ALL correct image choices that answer the question. Return ONLY the label(s) of your choice(s) (e.g., "IMAGE_CHOICE_1" or "IMAGE_CHOICE_1,IMAGE_CHOICE_2"), nothing else.\n\nQuestion: ${question}\n\nAvailable choices: ${choices.join(", ")}\n\nYour answer (label(s) only):`
                    : `Look at the images provided in the question. Then look at the choice images. Each choice image is labeled (IMAGE_CHOICE_1, IMAGE_CHOICE_2, etc.). Choose EXACTLY ONE image choice that best answers the question. Return ONLY the label of your choice (e.g., "IMAGE_CHOICE_1"), nothing else.\n\nQuestion: ${question}\n\nAvailable choices: ${choices.join(", ")}\n\nYour answer (one label only):`;
            } else if (isMultipleSelect) {
                prompt = `Answer this question by choosing ALL correct options from the following list. If there is only one correct answer, return just that one. If there are multiple correct answers, return them separated by commas. Return ONLY the exact text of your choice(s), nothing else.\n\nQuestion: ${question}\n\nOptions:\n${choices.map((c, i) => `${i + 1}. ${c}`).join("\n")}\n\nYour answer(s) (comma-separated if multiple):`;
            } else {
                prompt = `Answer this question by choosing EXACTLY ONE of the following options. Return ONLY the exact text of your choice, nothing else.\n\nQuestion: ${question}\n\nOptions:\n${choices.map((c, i) => `${i + 1}. ${c}`).join("\n")}\n\nYour answer (choose one exact option):`;
            }
        } else {
            prompt = `Answer directly and concisely. ONLY the final answer: ${question}`;
        }
        try {
            const totalImages = questionImages.length + choiceImages.length;
            log(`üöÄ Sending to GPT via gptApi${totalImages > 0 ? " with " + totalImages + " image(s)" : ""}...`);
            const messages = [{ role: "user", content: [{ type: "text", text: prompt }] }];
            if (questionImages.length) messages[0].content.push(...questionImages);
            if (choiceImages.length && hasImageChoices) {
                messages[0].content.push({ type: "text", text: "\n\nHere are the choice images:" });
                imageChoices.forEach((ch, idx) => {
                    if (idx < choiceImages.length) {
                        messages[0].content.push({ type: "text", text: `\n${ch.label}:` }, choiceImages[idx]);
                    }
                });
            }
            const gptFetch = getGPTFetch();
            const res = await gptFetch(GPT_BASE_URL, {
                method: "POST",
                headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
                body: JSON.stringify({ model: GPT_MODEL, messages, temperature: 0, max_tokens: 256 })
            });
            if (!res.ok) {
                const txt = await res.text();
                if (res.status === 429 || txt.includes("quota") || txt.includes("rate")) {
                    keyErrorCount[apiKey] = (keyErrorCount[apiKey] || 0) + 1;
                    if (keyErrorCount[apiKey] >= 5) {
                        log(`üóëÔ∏è Removing bad key after 5 failures: ${apiKey.slice(0, 5)}...${apiKey.slice(-5)}`);
                        apiKeysCache = apiKeysCache.filter(k => k !== apiKey);
                        delete keyErrorCount[apiKey];
                        if (!apiKeysCache.length) await fetchKeyFromGitHub(true);
                    }
                    throw new Error("Try again, this is something on our end");
                }
                throw new Error(`HTTP ${res.status}: ${txt}`);
            }
            keyErrorCount[apiKey] = 0;
            const data = await res.json();
            let answer = data.choices?.[0]?.message?.content || "";
            answer = answer.trim().replace(/^\$(.*?)\$/, "$1").trim().replace(/^\d+\.\s*/, "");
            if (choices && choices.length > 0) {
                if (isMultipleSelect) {
                    const answers = answer.split(/,|\n|and /i).map(a => a.trim().replace(/^\d+\.\s*/, "")).filter(a => a.length > 0);
                    const matched = [];
                    answers.forEach(ans => {
                        let m = choices.find(c => c.trim() === ans.trim() || c.toLowerCase().trim() === ans.toLowerCase().trim());
                        if (!m) m = choices.find(c => c.toLowerCase().includes(ans.toLowerCase()) || ans.toLowerCase().includes(c.toLowerCase()));
                        if (!m) {
                            const ansWords = ans.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                            m = choices.find(c => {
                                const cWords = c.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                                const matchCount = ansWords.filter(w => cWords.some(cw => cw.includes(w) || w.includes(cw))).length;
                                return matchCount >= Math.min(3, ansWords.length);
                            });
                        }
                        if (m && !matched.includes(m)) matched.push(m);
                    });
                    if (matched.length) { const res = matched.join(","); log(`‚úÖ GPT answer matched to ${matched.length} choice(s): ${res}`); return res; }
                } else {
                    let m = choices.find(c => c.trim() === answer.trim() || c.toLowerCase().trim() === answer.toLowerCase().trim());
                    if (!m) m = choices.find(c => c.toLowerCase().includes(answer.toLowerCase()) || answer.toLowerCase().includes(c.toLowerCase()));
                    if (!m) {
                        const ansWords = answer.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                        m = choices.find(c => {
                            const cWords = c.toLowerCase().split(/\s+/).filter(w => w.length > 3);
                            const matchCount = ansWords.filter(w => cWords.some(cw => cw.includes(w) || w.includes(cw))).length;
                            return matchCount >= Math.min(3, ansWords.length);
                        });
                    }
                    if (m) { log(`‚úÖ GPT answer matched to choice: ${m}`); return m; }
                }
            }
            log(`‚úÖ GPT answer received: ${answer}`);
            return answer;
        } catch (err) { log(`‚ùå GPT error: ${err.message}`); return null; }
    }

    /* --------------  FILL ANSWER  -------------- */
    function isValidResponse(a) {
        if (!a || typeof a !== "string") return false;
        const t = a.trim().toLowerCase();
        return t.length > 0 && !["no text", "error", "quota", "blocked", "limit", "unknown", "submit", "answer"].some(p => t.includes(p));
    }
    async function fillAnswer(answer) {
        const input = document.querySelector("input[type='text'], input[type='number']");
        if (input && isValidResponse(answer)) {
            input.value = answer;
            ["input", "change"].forEach(e => input.dispatchEvent(new Event(e, { bubbles: true })));
            log(`‚úÖ Filled input with: ${answer}`);
            lastKnownText = getTargetElementText();
            return true;
        }
        const { choices, isMultipleSelect } = getAvailableChoices();
        const answers = isMultipleSelect ? answer.split(",").map(a => a.trim()) : [answer];
        const expected = answers.length;
        let clicked = 0;
        for (const singleAnswer of answers) {
            if (singleAnswer.startsWith("IMAGE_CHOICE_")) {
                const el = imageChoiceMap[singleAnswer];
                if (el) {
                    const isMob = (el.className && el.className.includes("mobile")) || (el.querySelector && el.querySelector(".SelectableTile.mobile"));
                    if (isMob) {
                        const rect = (el.querySelector(".SelectableTile.mobile") || el).getBoundingClientRect();
                        const x = rect.left + rect.width / 2, y = rect.top + rect.height / 2;
                        await new Promise(resolve => setTimeout(() => {
                            const touch = new Touch({ identifier: Date.now(), target: el, clientX: x, clientY: y, radiusX: 2.5, radiusY: 2.5, rotationAngle: 0, force: 0.5 });
                            el.dispatchEvent(new TouchEvent("touchstart", { bubbles: true, cancelable: true, touches: [touch], targetTouches: [touch], changedTouches: [touch] }));
                            el.dispatchEvent(new TouchEvent("touchend", { bubbles: true, cancelable: true, touches: [], targetTouches: [], changedTouches: [touch] }));
                            log(`üì± Clicked mobile image choice: ${singleAnswer}`); clicked++; resolve();
                        }, 50));
                    } else {
                        const rect = el.getBoundingClientRect();
                        const x = rect.left + rect.width / 2, y = rect.top + rect.height / 2;
                        const cfg = { bubbles: true, cancelable: true, view: window, clientX: x, clientY: y, pointerId: 1, pointerType: "mouse", isPrimary: true, button: 0, buttons: 1 };
                        await new Promise(resolve => setTimeout(() => {
                            el.dispatchEvent(new PointerEvent("pointerenter", cfg));
                            el.dispatchEvent(new PointerEvent("pointerover", cfg));
                            el.dispatchEvent(new PointerEvent("pointermove", cfg));
                            el.dispatchEvent(new PointerEvent("pointerdown", cfg));
                            el.dispatchEvent(new PointerEvent("pointerup", { ...cfg, buttons: 0 }));
                            el.dispatchEvent(new MouseEvent("click", cfg));
                            log(`üñ±Ô∏è Clicked desktop image choice: ${singleAnswer}`); clicked++; resolve();
                        }, 50));
                    }
                    continue;
                }
            }
        }
        if (clicked === expected && clicked > 0) {
            const submitContainer = document.querySelector(".yui3-widget-ft.fade-in");
            if (submitContainer) {
                const submitBtn = Array.from(submitContainer.children).find(ch => ch.innerText.trim() === "Submit");
                if (submitBtn) { submitBtn.click(); log(`‚úÖ Submit button clicked after selecting ${clicked} image(s)`); }
            }
            lastKnownText = getTargetElementText(); return true;
        }
        let container = document.querySelector(".GriddyLayout.TOP") || document.querySelector(".VerticalLayout");
        if (container) {
            const children = Array.from(container.children);
            for (const singleAnswer of answers) {
                const norm = singleAnswer.trim().replace(/\s+/g, " ");
                const target = children.find(child => {
                    const walked = (() => { let w = ""; function walk(n) {
                        if (n.nodeType === Node.TEXT_NODE) { const t = n.textContent.trim(); if (t && t !== "Submit") w += t + " "; }
                        else if (n.nodeType === Node.ELEMENT_NODE) { const tag = n.tagName?.toLowerCase(); if (tag === "style" || tag === "script") return; n.childNodes.forEach(walk); }
                    } walk(child); return w.trim().replace(/\s+/g, " "); })();
                    return child.innerText.trim().replace(/\s+/g, " ") === norm || walked === norm;
                });
                if (target) {
                    const isMob = (target.className && target.className.includes("mobile")) || (target.querySelector && target.querySelector(".SelectableTile.mobile"));
                    if (isMob) {
                        const actual = target.querySelector(".SelectableTile.mobile") || target;
                        const rect = actual.getBoundingClientRect();
                        const x = rect.left + rect.width / 2, y = rect.top + rect.height / 2;
                        await new Promise(resolve => setTimeout(() => {
                            const touch = new Touch({ identifier: Date.now(), target: actual, clientX: x, clientY: y, radiusX: 2.5, radiusY: 2.5, rotationAngle: 0, force: 0.5 });
                            actual.dispatchEvent(new TouchEvent("touchstart", { bubbles: true, cancelable: true, touches: [touch], targetTouches: [touch], changedTouches: [touch] }));
                            actual.dispatchEvent(new TouchEvent("touchend", { bubbles: true, cancelable: true, touches: [], targetTouches: [], changedTouches: [touch] }));
                            log(`üì± Clicked mobile tile with Touch events: "${singleAnswer}"`); clicked++;
                            resolve();
                        }, 50));
                    } else {
                        const rect = target.getBoundingClientRect();
                        const x = rect.left + rect.width / 2, y = rect.top + rect.height / 2;
                        const cfg = { bubbles: true, cancelable: true, view: window, clientX: x, clientY: y, pointerId: 1, pointerType: "mouse", isPrimary: true, button: 0, buttons: 1 };
                        await new Promise(resolve => setTimeout(() => {
                            target.dispatchEvent(new PointerEvent("pointerenter", cfg));
                            target.dispatchEvent(new PointerEvent("pointerover", cfg));
                            target.dispatchEvent(new PointerEvent("pointermove", cfg));
                            target.dispatchEvent(new PointerEvent("pointerdown", cfg));
                            target.dispatchEvent(new PointerEvent("pointerup", { ...cfg, buttons: 0 }));
                            target.dispatchEvent(new MouseEvent("click", cfg));
                            log(`üñ±Ô∏è Clicked parent element containing text: "${singleAnswer}"`); clicked++;
                            resolve();
                        }, 50));
                    }
                }
            }
            if (clicked === expected && clicked > 0) {
                await new Promise(r => setTimeout(r, 200));
                const submitContainer = document.querySelector(".yui3-widget-ft.fade-in");
                if (submitContainer) {
                    const submitBtn = Array.from(submitContainer.children).find(ch => ch.innerText.trim() === "Submit");
                    if (submitBtn) { submitBtn.click(); log(`‚úÖ Submit button clicked after selecting all ${clicked} answer(s)`); }
                }
                lastKnownText = getTargetElementText(); return true;
            }
        }
        return false;
    }

    /* --------------  MAIN PROCESS  -------------- */
    async function processQuestion(retryCount = 0) {
        const MAX = 5;
        if (isProcessing && retryCount === 0) { log("‚è∏Ô∏è Already processing, skipping..."); return; }
        if (retryCount === 0) isProcessing = true;
        try {
            apiChange++;
            const question = getQuestionText();
            if (!question) {
                if (autoModeActive && retryCount < MAX) { log(`‚ö†Ô∏è No question found, retrying in 2s... (${retryCount + 1}/${MAX})`); await new Promise(r => setTimeout(r, 2000)); return processQuestion(retryCount + 1); }
                return;
            }
            log(`üìÑ QUESTION FOUND:\n${question}`);
            API_KEY = await fetchKeyFromGitHub();
            if (!API_KEY) {
                if (autoModeActive && retryCount < MAX) { log(`‚ö†Ô∏è Failed to get API key, retrying in 2s... (${retryCount + 1}/${MAX})`); await new Promise(r => setTimeout(r, 2000)); return processQuestion(retryCount + 1); }
                return;
            }
            const answer = await getAnswerFromGPT(question, API_KEY);
            if (!answer) {
                if (autoModeActive && retryCount < MAX) { log(`‚ö†Ô∏è Failed to get answer from GPT, retrying in 2s... (${retryCount + 1}/${MAX})`); await new Promise(r => setTimeout(r, 2000)); return processQuestion(retryCount + 1); }
                return;
            }
            const submitted = await fillAnswer(answer);
            if (!submitted && autoModeActive && retryCount < MAX) { log(`‚ö†Ô∏è Failed to submit answer, retrying in 2s... (${retryCount + 1}/${MAX})`); await new Promise(r => setTimeout(r, 2000)); return processQuestion(retryCount + 1); }
            if (autoModeActive && submitted) {
                const changed = await waitForTextChange(lastKnownText);
                if (changed) {
                    await new Promise(r => setTimeout(r, 1500));
                    log("üîÑ Processing next question...");
                    isProcessing = false;
                    processQuestion(); return;
                }
            }
        } catch (err) {
            log(`‚ùå Unexpected error: ${err.message}`);
            if (autoModeActive && retryCount < MAX) { log(`‚ö†Ô∏è Retrying due to error... (${retryCount + 1}/${MAX})`); await new Promise(r => setTimeout(r, 2000)); return processQuestion(retryCount + 1); }
        } finally { if (!autoModeActive) isProcessing = false; }
    }

    /* --------------  CHECKBOX SYNC  -------------- */
    function syncCheckboxState() {
        const cb = document.getElementById("appleCheckbox");
        if (cb) cb.checked = autoModeActive;
    }

    /* --------------  HOT-KEYS  -------------- */
    window.addEventListener("keydown", e => {
        const k = e.key.toLowerCase();
        if (k === "c" || k === "y") { e.preventDefault(); e.stopPropagation(); }
        if (k === "c" && !e.ctrlKey && !e.altKey && !e.metaKey) {
            log("‚å®Ô∏è 'C' pressed ‚Äî fetching new key and answering...");
            processQuestion();
        }
        if (k === "y" && !e.ctrlKey && !e.altKey && !e.metaKey) {
            autoModeActive = !autoModeActive;
            syncCheckboxState();
            if (autoModeActive) {
                log("ü§ñ Auto mode: ON. Will process next question.");
                let st = document.createElement("div");
                st.id = "__auto_status";
                st.style.cssText = "position:fixed;top:10px;left:10px;background:green;color:white;padding:4px 8px;border-radius:5px;z-index:99999;";
                st.innerText = "AUTO: ON";
                document.body.appendChild(st);
                setTimeout(() => { isProcessing = false; processQuestion(); }, 500);
            } else {
                log("ü§ñ Auto mode: OFF");
                isProcessing = false;
                const st = document.getElementById("__auto_status");
                if (st) st.remove();
            }
        }
    }, true);

    log("‚úÖ Helper ready. Press 'C' to get answer. Press 'Y' to toggle auto mode.");
})();

/* --------------  BOOT GUI  -------------- */
createtermkClientGUI();
